package net.jonathangiles.azure.shorturl.functions;

import com.microsoft.azure.functions.*;
import com.microsoft.azure.functions.HttpResponseMessage.Builder;
import com.microsoft.azure.functions.annotation.AuthorizationLevel;
import com.microsoft.azure.functions.annotation.FunctionName;
import com.microsoft.azure.functions.annotation.HttpTrigger;
import net.jonathangiles.azure.shorturl.storage.DataStore;
import net.jonathangiles.azure.shorturl.storage.DataStoreFactory;
import net.jonathangiles.azure.shorturl.util.SlackUtil;
import net.jonathangiles.azure.shorturl.util.Util;

import java.util.Optional;

/**
 * This class provides the function responsible for converting a long url into a short url.
 */
public class ShortcodeFunction {
    private static final String KEY_URL = "url";
    private static final String KEY_SHORTCODE = "shortcode";

    private static final int MIN_KEY_LENGTH = 2;

    @FunctionName("shortcode")
    public HttpResponseMessage shortcode(
            @HttpTrigger(name = "req",
                    methods = {HttpMethod.POST, HttpMethod.OPTIONS},
                    authLevel = AuthorizationLevel.ANONYMOUS) HttpRequestMessage<Optional<String>> request,
            final ExecutionContext context) {

        if (request.getHttpMethod() == HttpMethod.OPTIONS) {
            return request.createResponseBuilder(HttpStatus.OK)
                    .header("Access-Control-Allow-Credentials", "true")
                    .header("Access-Control-Allow-Origin", "*")
                    .header("Access-Control-Allow-Methods", "POST, OPTIONS")
                    .header("Access-Control-Allow-Headers", "Content-Type,url,shortcode")
                    .build();
        }

        String url = getHeaderOrQueryParam(request, KEY_URL, null);
        if (url == null) {
            return request.createResponseBuilder(HttpStatus.BAD_REQUEST).body("No url query parameter provided").build();
        }

        // if there is no tracking information, add the default tracking information here
        url = Util.addMicrosoftTracking(url, request);

        // we allow people to request their desired short code by setting a 'shortcode' query parameter
        String desiredShortcode = getHeaderOrQueryParam(request, KEY_SHORTCODE, null);

        Builder responseBuilder;

        if (desiredShortcode == null) {
            // the user just wants an auto-generated shortcode
            responseBuilder = useGeneratedShortcode(request, url, context);
        } else {
            // lets try to use their shortcode. If it fails, we return a failure.
            responseBuilder = useProvidedShortcode(request, url, desiredShortcode, context);
        }

        HttpResponseMessage response = responseBuilder
                .header("Access-Control-Allow-Credentials", "true")
                .header("Access-Control-Allow-Origin", "*")
                .build();

        context.getLogger().info("Response body:\n" + response.getBody());
        return response;
    }

    private String getHeaderOrQueryParam(HttpRequestMessage<?> request, String key, String defaultValue) {
        String value = request.getHeaders().getOrDefault(key, null);
        if (value == null || value.isEmpty()) {
            return request.getQueryParameters().getOrDefault(key, defaultValue);
        }
        return value;
    }

    private Builder useGeneratedShortcode(HttpRequestMessage<Optional<String>> request,
                                                              String url,
                                                              final ExecutionContext context) {
        context.getLogger().info("Attempting to create shortcode with url " + url + " and autogenerated shortcode");

        DataStore dataStore = DataStoreFactory.getInstance();

        String shortCode = "";
        int collisionCount = 0;
        int keyLength = MIN_KEY_LENGTH;
        while (shortCode == null || shortCode.isEmpty()) {
            shortCode = dataStore.saveShortCode(url, Util.generateKey(keyLength), true);

            // if we are here, the proposed shortcode failed, so we count that.
            // If we get too many collisions, increase the key length by one and
            // keep trying
            collisionCount++;
            if (collisionCount > 3) {
                keyLength++;
                collisionCount = 0;
            }
        }

        context.getLogger().info("Created short code: " + shortCode);
        SlackUtil.sendMessage("Shortlink created: " + shortCode + " for url " + url, SlackUtil.CHANNEL_GENERAL);

        return request.createResponseBuilder(HttpStatus.OK).body(createShortUrl(request, shortCode));
    }

    private Builder useProvidedShortcode(HttpRequestMessage<Optional<String>> request,
                                                             String url,
                                                             String shortcode,
                                                             final ExecutionContext context) {
        context.getLogger().info("Attempting to create shortcode with url " + url + " and shortcode " + shortcode);

        DataStore dataStore = DataStoreFactory.getInstance();

        // we set checkForDupes to be false, so that we allow this short code to be used, even if the long URL is
        // recorded elsewhere
        String result = dataStore.saveShortCode(url, shortcode, false);
        if (result == null) {
            return request.createResponseBuilder(HttpStatus.CONFLICT).body("Requested shortcode already in use");
        }

        SlackUtil.sendMessage("Shortlink created: " + shortcode + " for url " + url, SlackUtil.CHANNEL_GENERAL);

        return request.createResponseBuilder(HttpStatus.OK).body(createShortUrl(request, result));
    }

    private String createShortUrl(HttpRequestMessage<Optional<String>> request, String shortCode) {
        return "{\"url\": \"http://" + Util.getHost(request).getHost() + "/" + shortCode + "\"}";
    }
}
